<HTML>
<HEAD>
<TITLE>EX_patch</TITLE>
<LINK REL="STYLESHEET" TYPE="TEXT/CSS" HREF="style.css">
</HEAD>
<BODY BGCOLOR="#FFFFF8">
<TABLE CLASS="INVTABLE" WIDTH="100%">
<TR>
<TD CLASS="NOBORDER" WIDTH="40"><IMG SRC="function.gif" WIDTH="32" HEIGHT="32" BORDER="0"></TD>
<TD CLASS="TITLE">EX_patch</TD>
<TD CLASS="DESCRIPTION">Function (ROM Call 0x15A)</TD>
</TR>
</TABLE>
<HR>
<TABLE CLASS="NOBORDER" WIDTH="100%"><TR>
<TD CLASS="HEADER" ALIGN="RIGHT"><A HREF="system.html">system.h</A>
</TD>
</TR></TABLE>
<P><TABLE CLASS="DEFTABLE"><TR><TD CLASS="DEFINITION"><B><A HREF="keywords_void.html">void</A></B> EX_patch (<B><A HREF="keywords_void.html">void</A></B> *base_addr, <B><A HREF="keywords_void.html">void</A></B> *tag_ptr);</TD></TR></TABLE>
<P CLASS="ITEMDESC"><B>Relocates an assembly program.</B>
<P>EX_patch relocates relocatable items in the assembly program (.89z or .9xz file), where
<I>tag_ptr</I> points to the "PROGRAM" signature (tag) byte (byte 0xF3), and
<I>base_addr</I> is the address from where the assembly program will be started.
So, if <I>handle</I> is a handle of an .89z (or .9xz) file, you can execute it using
<PRE>len = *(unsigned short*)(base_ptr = HLock (handle));
EX_patch (base_ptr + 2, base_ptr + len + 1);
ASM_call (base_ptr + 2);
HeapUnlock (handle);
</PRE>
In practice, some protection devices in HW2 calculators make the whole thing much more
complicated (see the <A HREF="faq_49.html">launcher</A> FAQ entry for more info).
<BR><BR>
Note that the relocation table ends just below the tag byte.
<BR><BR>
<B>Note:</B> If <I>base_addr</I> is in the ghost space,
<I>tag_ptr</I> has to be in the ghost space, too!
<P><HR>Used by: <A HREF="dll_LoadDLL.html">LoadDLL</A>, <A HREF="unknown_push_user_func.html">push_user_func</A>
<P><HR>See also: <A HREF="system_enter_ghost_space.html">enter_ghost_space</A>, <A HREF="httigcc_advanced_ghostspace.html">EXECUTE_IN_GHOST_SPACE</A>
</BODY>
</HTML>
